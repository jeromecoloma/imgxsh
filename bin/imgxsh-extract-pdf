#!/bin/bash

# imgxsh-extract-pdf - Extract images from PDF files
# Default: rasterize pages to images using ImageMagick; Optional: extract embedded images via pdfimages

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SHELL_STARTER_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

source "${SHELL_STARTER_ROOT}/lib/main.sh"

# Default values
readonly DEFAULT_QUALITY=85
readonly DEFAULT_FORMAT="jpg"
readonly DEFAULT_PREFIX="page"

# Global variables
PDF_FILE=""
OUTPUT_DIR=""
QUALITY="${DEFAULT_QUALITY}"
FORMAT="${DEFAULT_FORMAT}"
PREFIX="${DEFAULT_PREFIX}"
PAGE_RANGE=""
VERBOSE=false
QUIET=false
DRY_RUN=false
OVERWRITE=false
BACKUP=false
LIST_ONLY=false
EXTRACT_METADATA=true
KEEP_ORIGINAL_NAMES=false
EXTRACT_MODE="raster" # raster | embedded

show_help() {
	cat <<EOF
Usage: $(basename "$0") [OPTIONS] PDF_FILE OUTPUT_DIR

Extract images from PDF files. By default, pages are rasterized to images using ImageMagick. Use --embedded-images to extract original embedded raster images via pdfimages.

ARGUMENTS:
    PDF_FILE              Path to the PDF file to extract images from
    OUTPUT_DIR            Directory to save extracted images

OPTIONS:
    -h, --help            Show this help message and exit
    -v, --version         Show version information and exit
    -q, --quiet           Suppress verbose output
    --verbose             Enable detailed logging
    --dry-run             Preview operations without execution
    --overwrite           Overwrite existing files without prompting
    --backup              Create backup of existing files before overwriting
    
    -f, --format FORMAT   Output format (jpg, png, tiff, bmp) [default: jpg]
    -q, --quality QUALITY Quality setting for lossy formats (1-100) [default: 85]
    -p, --prefix PREFIX   Prefix for extracted image names [default: page]
    --page-range RANGE    Extract specific pages (e.g., "1-5", "1,3,7", "2-")
    --list-only           Show summary of PDF (Pages and Embedded images) without extracting
    --embedded-images     Extract embedded raster images (uses pdfimages); default is rasterized pages
    --no-metadata         Skip metadata extraction and preservation
    --keep-names          Keep original image names from PDF
    
    --check-deps          Check for required dependencies and exit
    --update              Check for imgxsh updates
    --check-version       Check current version information

EXAMPLES:
    # Extract all images to output directory
    # Default (rasterize one image per page at 300 DPI, JPG quality 90)
    $(basename "$0") document.pdf ./extracted/
    
    # Extract embedded images instead of rasterizing pages
    $(basename "$0") --embedded-images document.pdf ./extracted/
    
    # Extract specific pages with custom naming
    $(basename "$0") --page-range "1-5" --prefix "chapter1" document.pdf ./images/
    
    # Extract as PNG with high quality
    $(basename "$0") --format png --quality 95 document.pdf ./high-res/
    
    # List-only: show pages and embedded images count
    $(basename "$0") --list-only document.pdf ./temp/
    
    # Dry run to preview operations
    $(basename "$0") --dry-run --verbose document.pdf ./output/

DEPENDENCIES:
    ImageMagick (magick/convert) - Required for default rasterized page extraction
    pdfinfo (poppler-utils)      - Recommended, for page counting in list-only and metadata
    pdfimages (poppler-utils)    - Required for --embedded-images and embedded count in list-only

FORMATS SUPPORTED:
    jpg, png, tiff, bmp - Output formats supported by ImageMagick
    Original format detection from PDF embedded images

For more information, visit: https://github.com/jeromecoloma/imgxsh
EOF
}

check_dependencies() {
	local missing_deps=()
	local optional_deps=()

	# ImageMagick required for default raster extraction
	if ! command -v convert >/dev/null 2>&1 && ! command -v magick >/dev/null 2>&1; then
		if [[ "$EXTRACT_MODE" == "raster" ]]; then
			# In dry-run or list-only modes, allow missing ImageMagick (we only print commands)
			if [[ "$DRY_RUN" == true || "$LIST_ONLY" == true ]]; then
				optional_deps+=("ImageMagick")
			else
				missing_deps+=("ImageMagick")
			fi
		else
			optional_deps+=("ImageMagick")
		fi
	fi

	# pdfimages is required when extracting embedded images; optional for list-only summary
	if ! command -v pdfimages >/dev/null 2>&1; then
		if [[ "$EXTRACT_MODE" == "embedded" ]]; then
			missing_deps+=("pdfimages")
		else
			optional_deps+=("pdfimages")
		fi
	fi

	# pdfinfo recommended for page count and metadata
	if ! command -v pdfinfo >/dev/null 2>&1; then
		optional_deps+=("pdfinfo")
	fi

	if [[ ${#missing_deps[@]} -gt 0 ]]; then
		log::error "Required dependencies missing: ${missing_deps[*]}"
		log::info "Install dependencies:"
		log::info "  macOS: brew install poppler"
		log::info "  Ubuntu/Debian: sudo apt-get install imagemagick poppler-utils"
		log::info "  CentOS/RHEL: sudo yum install poppler-utils"
		log::info "  Arch Linux: sudo pacman -S poppler"
		return 1
	fi

	if [[ ${#optional_deps[@]} -gt 0 ]]; then
		log::warn "Optional dependencies missing: ${optional_deps[*]}"
		log::info "Install suggestions:"
		log::info "  macOS: brew install imagemagick poppler"
		log::info "  Ubuntu/Debian: sudo apt-get install imagemagick poppler-utils"
		log::info "  CentOS/RHEL: sudo yum install ImageMagick poppler-utils"
		log::info "  Arch Linux: sudo pacman -S imagemagick poppler"
	fi

	return 0
}

validate_pdf_file() {
	local pdf_file="$1"

	if [[ ! -f "$pdf_file" ]]; then
		log::error "PDF file does not exist: $pdf_file"
		return 1
	fi

	if [[ ! -r "$pdf_file" ]]; then
		log::error "Cannot read PDF file: $pdf_file"
		return 1
	fi

	# Check if file is actually a PDF
	if ! file "$pdf_file" | grep -qi "pdf document"; then
		log::error "File does not appear to be a PDF: $pdf_file"
		return 1
	fi

	return 0
}

validate_output_dir() {
	local output_dir="$1"

	if [[ -f "$output_dir" ]]; then
		log::error "Output path is a file, not a directory: $output_dir"
		return 1
	fi

	if [[ ! -d "$output_dir" ]]; then
		if [[ "$DRY_RUN" == true ]]; then
			log::info "Would create output directory: $output_dir"
		else
			log::info "Creating output directory: $output_dir"
			if ! mkdir -p "$output_dir"; then
				log::error "Failed to create output directory: $output_dir"
				return 1
			fi
		fi
	fi

	if [[ ! -w "$output_dir" ]] && [[ "$DRY_RUN" != true ]]; then
		log::error "Cannot write to output directory: $output_dir"
		return 1
	fi

	return 0
}

validate_format() {
	local format="$1"
	local valid_formats=("jpg" "jpeg" "png" "tiff" "bmp")

	# Convert to lowercase for comparison
	format=$(echo "$format" | tr '[:upper:]' '[:lower:]')

	for valid_format in "${valid_formats[@]}"; do
		if [[ "$format" == "$valid_format" ]]; then
			echo "$format"
			return 0
		fi
	done

	log::error "Invalid format: $format"
	log::info "Supported formats: ${valid_formats[*]}"
	return 1
}

validate_quality() {
	local quality="$1"

	if ! [[ "$quality" =~ ^[0-9]+$ ]]; then
		log::error "Quality must be a number: $quality"
		return 1
	fi

	if [[ "$quality" -lt 1 || "$quality" -gt 100 ]]; then
		log::error "Quality must be between 1 and 100: $quality"
		return 1
	fi

	return 0
}

parse_page_range() {
	local range="$1"

	if [[ -z "$range" ]]; then
		return 0
	fi

	# Validate page range format
	if [[ ! "$range" =~ ^[0-9,-]+$ ]]; then
		log::error "Invalid page range format: $range"
		log::info "Valid formats: '1-5', '1,3,7', '2-', '1-3,5,7-10'"
		return 1
	fi

	return 0
}

list_pdf_images() {
	local pdf_file="$1"
	local output_dir="$2"

	log::info "Listing images in PDF: $pdf_file"

	# Use pdfimages to list images
	if ! pdfimages -list "$pdf_file" >"$output_dir/pdf_images_list.txt" 2>/dev/null; then
		log::error "Failed to list images from PDF"
		return 1
	fi

	local image_count
	image_count=$(grep -c "^[[:space:]]*[0-9]" "$output_dir/pdf_images_list.txt" 2>/dev/null || echo "0")
	image_count=$(echo "$image_count" | tr -d '\n')

	if [[ "$image_count" -eq 0 ]]; then
		log::warn "No images found in PDF: $pdf_file"
		return 0
	fi

	log::info "Found $image_count images in PDF"

	if [[ "$VERBOSE" == true ]]; then
		log::info "Image details:"
		cat "$output_dir/pdf_images_list.txt"
	fi

	return 0
}

list_pdf_summary() {
	local pdf_file="$1"
	local output_dir="$2"

	log::info "Analyzing PDF: $pdf_file"

	local pages="unknown"
	if command -v pdfinfo >/dev/null 2>&1; then
		pages=$(pdfinfo "$pdf_file" 2>/dev/null | awk -F': *' '/^Pages/ {print $2; exit}')
		pages=${pages:-unknown}
	else
		log::warn "pdfinfo not available; cannot determine page count"
	fi

	local embedded_images="0"
	if command -v pdfimages >/dev/null 2>&1; then
		if pdfimages -list "$pdf_file" >"$output_dir/pdf_images_list.txt" 2>/dev/null; then
			embedded_images=$(grep -c "^[[:space:]]*[0-9]" "$output_dir/pdf_images_list.txt" 2>/dev/null || echo "0")
			embedded_images=$(echo "$embedded_images" | tr -d '\n')
		else
			log::warn "Failed to list embedded images via pdfimages"
		fi
	else
		log::warn "pdfimages not available; embedded image count unavailable"
	fi

	log::info "Pages: ${pages}"
	log::info "Embedded images: ${embedded_images}"

	if [[ "$VERBOSE" == true && -f "$output_dir/pdf_images_list.txt" ]]; then
		log::info "Embedded image details:"
		cat "$output_dir/pdf_images_list.txt"
	fi
}

extract_pdf_images() {
	local pdf_file="$1"
	local output_dir="$2"

	if [[ "$QUIET" != true ]]; then
		log::info "Extracting images from PDF: $pdf_file"
		log::info "Output directory: $output_dir"
	fi

	# Create temporary directory for extraction
	local temp_dir
	temp_dir=$(mktemp -d)

	# Extract images using pdfimages (embedded mode)
	local pdfimages_cmd="pdfimages"
	local pdfimages_args=()

	# Add format specification if not keeping original names
	if [[ "$KEEP_ORIGINAL_NAMES" == false ]]; then
		case "$FORMAT" in
		jpg | jpeg)
			pdfimages_args+=("-j")
			;;
		png)
			pdfimages_args+=("-png")
			;;
		tiff)
			pdfimages_args+=("-tiff")
			;;
		*)
			# For other formats, let pdfimages handle them
			;;
		esac
	fi

	# Add page range if specified
	if [[ -n "$PAGE_RANGE" ]]; then
		pdfimages_args+=("-f" "$(echo "$PAGE_RANGE" | cut -d'-' -f1)")
		pdfimages_args+=("-l" "$(echo "$PAGE_RANGE" | cut -d'-' -f2)")
	fi

	# Add output prefix
	pdfimages_args+=("$pdf_file" "$temp_dir/$PREFIX")

	if [[ "$DRY_RUN" == true ]]; then
		log::info "Would run: $pdfimages_cmd ${pdfimages_args[*]}"
		rm -rf "$temp_dir"
		return 0
	fi

	# Run pdfimages
	if ! $pdfimages_cmd "${pdfimages_args[@]}" 2>/dev/null; then
		log::error "Failed to extract images from PDF"
		rm -rf "$temp_dir"
		return 1
	fi

	# Count extracted images
	local extracted_count=0
	local processed_count=0

	for image_file in "$temp_dir"/*; do
		if [[ -f "$image_file" ]]; then
			((extracted_count++))

			local basename_file
			basename_file=$(basename "$image_file")
			local output_file="$output_dir/$basename_file"

			# Handle file naming
			if [[ "$KEEP_ORIGINAL_NAMES" == false ]]; then
				# Use template-based naming
				local page_num
				page_num=$(printf "%03d" "$extracted_count")
				output_file="$output_dir/${PREFIX}_${page_num}.$FORMAT"
			fi

			# Convert format if needed and apply quality settings
			if [[ "$FORMAT" != "png" && "$FORMAT" != "tiff" ]]; then
				if command -v convert >/dev/null 2>&1; then
					if ! convert "$image_file" -quality "$QUALITY" "$output_file" 2>/dev/null; then
						log::warn "Failed to convert $basename_file, copying original"
						cp "$image_file" "$output_file"
					fi
				else
					cp "$image_file" "$output_file"
				fi
			else
				cp "$image_file" "$output_file"
			fi

			((processed_count++))

			if [[ "$VERBOSE" == true ]]; then
				log::info "Extracted: $basename_file -> $(basename "$output_file")"
			fi
		fi
	done

	# Clean up temporary directory
	rm -rf "$temp_dir"

	if [[ "$extracted_count" -eq 0 ]]; then
		log::warn "No images were extracted from PDF"
		return 0
	fi

	log::success "Successfully extracted $processed_count images"

	# Extract metadata if requested
	if [[ "$EXTRACT_METADATA" == true ]]; then
		extract_pdf_metadata "$pdf_file" "$output_dir"
	fi

	return 0
}

extract_rasterized_pages() {
	local pdf_file="$1"
	local output_dir="$2"

	if [[ "$QUIET" != true ]]; then
		log::info "Rasterizing pages from PDF: $pdf_file"
		log::info "Output directory: $output_dir"
	fi

	local magick_cmd=""
	if command -v magick >/dev/null 2>&1; then
		magick_cmd="magick"
	elif command -v convert >/dev/null 2>&1; then
		magick_cmd="convert"
	else
		log::error "ImageMagick not found (magick/convert)"
		return 1
	fi

	local density=300
	local output_pattern="$output_dir/${PREFIX}-%02d.$FORMAT"

	local range_input="$pdf_file"
	if [[ -n "$PAGE_RANGE" ]]; then
		# Convert simple "a-b" to [a-b], otherwise leave to ImageMagick default
		# Note: Complex ranges like 1,3,7 aren't directly supported by IM in one call
		if [[ "$PAGE_RANGE" =~ ^[0-9]+-[0-9]+$ ]]; then
			range_input="${pdf_file}[$PAGE_RANGE]"
		else
			log::warn "Complex page ranges are not fully supported for raster mode; rendering full document"
		fi
	fi

	if [[ "$DRY_RUN" == true ]]; then
		log::info "Would run: $magick_cmd -density $density \"$range_input\" -quality $QUALITY \"$output_pattern\""
		return 0
	fi

	if ! $magick_cmd -density $density "$range_input" -quality "$QUALITY" "$output_pattern" 2>/dev/null; then
		log::error "Failed to rasterize PDF pages"
		return 1
	fi

	# Count generated files
	local count=0
	shopt -s nullglob
	for f in "$output_dir"/"${PREFIX}-"*."$FORMAT"; do
		[[ -f "$f" ]] && ((count++))
	done
	shopt -u nullglob

	if [[ "$count" -eq 0 ]]; then
		log::warn "No pages were rasterized (no output files created)"
		return 0
	fi

	log::success "Successfully rendered $count page images"

	if [[ "$EXTRACT_METADATA" == true ]]; then
		extract_pdf_metadata "$pdf_file" "$output_dir"
	fi

	return 0
}

extract_pdf_metadata() {
	local pdf_file="$1"
	local output_dir="$2"

	log::info "Extracting PDF metadata"

	# Create metadata file
	local metadata_file="$output_dir/pdf_metadata.txt"

	{
		echo "PDF File: $pdf_file"
		echo "Extraction Date: $(date)"
		echo "Extraction Tool: imgxsh-extract-pdf $(get_version)"
		echo ""
		echo "PDF Information:"
		pdfinfo "$pdf_file" 2>/dev/null || echo "pdfinfo not available"
	} >"$metadata_file"

	if [[ "$VERBOSE" == true ]]; then
		log::info "Metadata saved to: $metadata_file"
	fi
}

main() {
	# Parse command line arguments
	while [[ $# -gt 0 ]]; do
		case $1 in
		-h | --help)
			show_help
			exit 0
			;;
		-v | --version)
			echo "$(basename "$0") $(get_version)"
			exit 0
			;;
		-q | --quiet)
			QUIET=true
			shift
			;;
		--verbose)
			VERBOSE=true
			shift
			;;
		--dry-run)
			DRY_RUN=true
			shift
			;;
		--overwrite)
			OVERWRITE=true
			shift
			;;
		--backup)
			BACKUP=true
			shift
			;;
		-f | --format)
			FORMAT="$2"
			shift 2
			;;
		--quality)
			QUALITY="$2"
			shift 2
			;;
		-p | --prefix)
			PREFIX="$2"
			shift 2
			;;
		--page-range)
			PAGE_RANGE="$2"
			shift 2
			;;
		--list-only)
			LIST_ONLY=true
			shift
			;;
		--no-metadata)
			EXTRACT_METADATA=false
			shift
			;;
		--keep-names)
			KEEP_ORIGINAL_NAMES=true
			shift
			;;
		--embedded-images)
			EXTRACT_MODE="embedded"
			shift
			;;
		--check-deps)
			check_dependencies
			exit $?
			;;
		--update)
			# In test mode, avoid network calls and heavy operations
			if [[ "${TEST_MODE:-}" == "true" ]]; then
				echo "update-imgxsh (test-mode)"
				exit 0
			fi
			if command -v update-imgxsh >/dev/null 2>&1; then
				update-imgxsh --check
			else
				log::error "update-imgxsh not available"
				exit 1
			fi
			;;
		--check-version)
			echo "imgxsh-extract-pdf $(get_version)"
			IMGXSH_REPO="jeromecoloma/imgxsh" "${SHELL_STARTER_ROOT}/scripts/check-version.sh" status || true
			exit 0
			;;
		-*)
			log::error "Unknown option: $1"
			show_help
			exit 1
			;;
		*)
			# Positional arguments
			if [[ -z "$PDF_FILE" ]]; then
				PDF_FILE="$1"
			elif [[ -z "$OUTPUT_DIR" ]]; then
				OUTPUT_DIR="$1"
			else
				log::error "Too many arguments"
				show_help
				exit 1
			fi
			shift
			;;
		esac
	done

	# Validate required arguments
	if [[ -z "$PDF_FILE" ]]; then
		log::error "PDF file is required"
		show_help
		exit 1
	fi

	if [[ -z "$OUTPUT_DIR" ]]; then
		log::error "Output directory is required"
		show_help
		exit 1
	fi

	# Validate inputs
	if ! validate_pdf_file "$PDF_FILE"; then
		exit 1
	fi

	if ! validate_output_dir "$OUTPUT_DIR"; then
		exit 1
	fi

	# Validate format
	if ! FORMAT=$(validate_format "$FORMAT"); then
		exit 1
	fi

	# Validate quality
	if ! validate_quality "$QUALITY"; then
		exit 1
	fi

	# Validate page range
	if ! parse_page_range "$PAGE_RANGE"; then
		exit 1
	fi

	# Check dependencies
	if ! check_dependencies; then
		exit 1
	fi

	# Set quiet mode
	if [[ "$QUIET" == true ]]; then
		VERBOSE=false
	fi

	# Main processing
	if [[ "$QUIET" != true ]]; then
		log::info "Starting PDF image extraction..."
		log::info "PDF: $PDF_FILE"
		log::info "Output: $OUTPUT_DIR"
		log::info "Format: $FORMAT"
		log::info "Quality: $QUALITY"
		if [[ -n "$PAGE_RANGE" ]]; then
			log::info "Page range: $PAGE_RANGE"
		fi
		if [[ "$DRY_RUN" == true ]]; then
			log::info "DRY RUN MODE - No files will be modified"
		fi
	fi

	# List only mode
	if [[ "$LIST_ONLY" == true ]]; then
		list_pdf_summary "$PDF_FILE" "$OUTPUT_DIR" || true
		exit 0
	fi

	# Extract
	if [[ "$EXTRACT_MODE" == "embedded" ]]; then
		if ! extract_pdf_images "$PDF_FILE" "$OUTPUT_DIR"; then
			exit 1
		fi
	else
		if ! extract_rasterized_pages "$PDF_FILE" "$OUTPUT_DIR"; then
			exit 1
		fi
	fi

	if [[ "$QUIET" != true ]]; then
		log::success "PDF image extraction completed successfully"
	fi
}

# Only run main if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	main "$@"
fi
