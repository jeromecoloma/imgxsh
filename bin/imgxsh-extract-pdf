#!/bin/bash

# imgxsh-extract-pdf - Extract images from PDF files
# Default: rasterize pages to images using ImageMagick; Optional: extract embedded images via pdfimages

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SHELL_STARTER_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

source "${SHELL_STARTER_ROOT}/lib/main.sh"

# Default values
readonly DEFAULT_QUALITY=85
readonly DEFAULT_FORMAT="jpg"
readonly DEFAULT_PREFIX="page"

# Global variables
PDF_FILE=""
OUTPUT_DIR=""
QUALITY="${DEFAULT_QUALITY}"
FORMAT="${DEFAULT_FORMAT}"
PREFIX="${DEFAULT_PREFIX}"
PAGE_RANGE=""
VERBOSE=false
QUIET=false
DRY_RUN=false
OVERWRITE=false
BACKUP=false
LIST_ONLY=false
EXTRACT_METADATA=true
KEEP_ORIGINAL_NAMES=false
EXTRACT_MODE="raster" # raster | embedded

show_help() {
	cat <<EOF
Usage: $(basename "$0") [OPTIONS] PDF_FILE OUTPUT_DIR

Extract images from PDF files. By default, pages are rasterized to images using ImageMagick. Use --embedded-images to extract original embedded raster images via pdfimages.

ARGUMENTS:
    PDF_FILE              Path to the PDF file to extract images from
    OUTPUT_DIR            Directory to save extracted images

OPTIONS:
    -h, --help            Show this help message and exit
    -v, --version         Show version information and exit
    -q, --quiet           Suppress verbose output
    --verbose             Enable detailed logging
    --dry-run             Preview operations without execution
    --overwrite           Overwrite existing files without prompting
    --backup              Create backup of existing files before overwriting
    
    -f, --format FORMAT   Output format (jpg, png, tiff, bmp) [default: jpg]
    -q, --quality QUALITY Quality setting for lossy formats (1-100) [default: 85]
    -p, --prefix PREFIX   Prefix for extracted image names [default: page]
    --page-range RANGE    Extract specific pages (e.g., "1-5", "1,3,7", "2-", "1-3,5,7-9")
    --list-only           Show summary of PDF (Pages and Embedded images) without extracting
    --embedded-images     Extract embedded raster images (uses pdfimages); default is rasterized pages
    --no-metadata         Skip metadata extraction and preservation
    --keep-names          Keep original image names from PDF
    
    --check-deps          Check for required dependencies and exit
    --update              Check for imgxsh updates
    --check-version       Check current version information

EXAMPLES:
    # Extract all images to output directory
    # Default (rasterize one image per page at 300 DPI, JPG quality 90)
    $(basename "$0") document.pdf ./extracted/
    
    # Extract embedded images instead of rasterizing pages
    $(basename "$0") --embedded-images document.pdf ./extracted/
    
    # Extract specific pages with custom naming
    $(basename "$0") --page-range "1-5" --prefix "chapter1" document.pdf ./images/
    
    # Batch process multiple PDFs (use in scripts)
    for pdf in *.pdf; do
        \$(basename "\$0") "\$pdf" "./extracted/\${pdf%.pdf}/"
    done
    
    # Extract complex page ranges (mixed ranges and individual pages)
    $(basename "$0") --page-range "1,3,7,10-12" document.pdf ./images/
    
    # Extract from page 5 to end of document
    $(basename "$0") --page-range "5-" document.pdf ./images/
    
    # Extract as PNG with high quality
    $(basename "$0") --format png --quality 95 document.pdf ./high-res/
    
    # List-only: show pages and embedded images count
    $(basename "$0") --list-only document.pdf ./temp/
    
    # Dry run to preview operations
    $(basename "$0") --dry-run --verbose document.pdf ./output/

PAGE RANGE FORMATS:
    Simple range:     "1-5"     (pages 1 through 5)
    Individual pages: "1,3,7"   (pages 1, 3, and 7)
    Open range:       "5-"      (from page 5 to end)
    Mixed ranges:     "1-3,5,7-9" (pages 1-3, 5, and 7-9)
    
    Note: Pages are processed individually to maintain correct output numbering.
    Output files are numbered sequentially (page-01.jpg, page-02.jpg, etc.)
    regardless of which source pages are selected.

DEPENDENCIES:
    ImageMagick (magick/convert) - Required for default rasterized page extraction
    pdfinfo (poppler-utils)      - Recommended, for page counting in list-only and metadata
    pdfimages (poppler-utils)    - Required for --embedded-images and embedded count in list-only

FORMATS SUPPORTED:
    jpg, png, tiff, bmp - Output formats supported by ImageMagick
    Original format detection from PDF embedded images

For more information, visit: https://github.com/jeromecoloma/imgxsh
EOF
}

check_dependencies() {
	local missing_deps=()
	local optional_deps=()

	# ImageMagick required for default raster extraction
	if ! command -v convert >/dev/null 2>&1 && ! command -v magick >/dev/null 2>&1; then
		if [[ $EXTRACT_MODE == "raster" ]]; then
			# In dry-run or list-only modes, allow missing ImageMagick (we only print commands)
			if [[ $DRY_RUN == true || $LIST_ONLY == true ]]; then
				optional_deps+=("ImageMagick")
			else
				missing_deps+=("ImageMagick")
			fi
		else
			optional_deps+=("ImageMagick")
		fi
	fi

	# pdfimages is required when extracting embedded images; optional for list-only summary
	if ! command -v pdfimages >/dev/null 2>&1; then
		if [[ $EXTRACT_MODE == "embedded" ]]; then
			missing_deps+=("pdfimages")
		else
			optional_deps+=("pdfimages")
		fi
	fi

	# pdfinfo recommended for page count and metadata
	if ! command -v pdfinfo >/dev/null 2>&1; then
		optional_deps+=("pdfinfo")
	fi

	if [[ ${#missing_deps[@]} -gt 0 ]]; then
		log::error "Required dependencies missing: ${missing_deps[*]}"
		log::info "Install dependencies:"
		log::info "  macOS: brew install poppler"
		log::info "  Ubuntu/Debian: sudo apt-get install imagemagick poppler-utils"
		log::info "  CentOS/RHEL: sudo yum install poppler-utils"
		log::info "  Arch Linux: sudo pacman -S poppler"
		return 1
	fi

	if [[ ${#optional_deps[@]} -gt 0 ]]; then
		log::warn "Optional dependencies missing: ${optional_deps[*]}"
		log::info "Install suggestions:"
		log::info "  macOS: brew install imagemagick poppler"
		log::info "  Ubuntu/Debian: sudo apt-get install imagemagick poppler-utils"
		log::info "  CentOS/RHEL: sudo yum install ImageMagick poppler-utils"
		log::info "  Arch Linux: sudo pacman -S imagemagick poppler"
	fi

	return 0
}

validate_pdf_file() {
	local pdf_file="$1"

	if [[ ! -f $pdf_file ]]; then
		log::error "PDF file does not exist: $pdf_file"
		return 1
	fi

	if [[ ! -r $pdf_file ]]; then
		log::error "Cannot read PDF file: $pdf_file"
		return 1
	fi

	# Check if file is actually a PDF
	if ! file "$pdf_file" | grep -qi "pdf document"; then
		log::error "File does not appear to be a PDF: $pdf_file"
		return 1
	fi

	return 0
}

validate_output_dir() {
	local output_dir="$1"

	if [[ -f $output_dir ]]; then
		log::error "Output path is a file, not a directory: $output_dir"
		return 1
	fi

	if [[ ! -d $output_dir ]]; then
		if [[ $DRY_RUN == true ]]; then
			log::info "Would create output directory: $output_dir"
		else
			echo ""
			log::info "Creating output directory: $output_dir"
			if ! mkdir -p "$output_dir"; then
				log::error "Failed to create output directory: $output_dir"
				return 1
			fi
		fi
	fi

	if [[ ! -w $output_dir ]] && [[ $DRY_RUN != true ]]; then
		log::error "Cannot write to output directory: $output_dir"
		return 1
	fi

	return 0
}

validate_format() {
	local format="$1"
	local valid_formats=("jpg" "jpeg" "png" "tiff" "bmp")

	# Convert to lowercase for comparison
	format=$(echo "$format" | tr '[:upper:]' '[:lower:]')

	for valid_format in "${valid_formats[@]}"; do
		if [[ $format == "$valid_format" ]]; then
			echo "$format"
			return 0
		fi
	done

	log::error "Invalid format: $format"
	log::info "Supported formats: ${valid_formats[*]}"
	return 1
}

validate_quality() {
	local quality="$1"

	if ! [[ $quality =~ ^[0-9]+$ ]]; then
		log::error "Quality must be a number: $quality"
		return 1
	fi

	if [[ $quality -lt 1 || $quality -gt 100 ]]; then
		log::error "Quality must be between 1 and 100: $quality"
		return 1
	fi

	return 0
}

parse_page_range() {
	local range="$1"

	if [[ -z $range ]]; then
		return 0
	fi

	# Validate page range format
	if [[ ! $range =~ ^[0-9,-]+$ ]]; then
		log::error "Invalid page range format: $range"
		log::info "Valid formats: '1-5', '1,3,7', '2-', '1-3,5,7-10'"
		return 1
	fi

	return 0
}

# Parse complex page ranges and return array of page numbers
parse_complex_page_range() {
	local range="$1"
	local pages_array_name="$2"

	# Initialize the array
	eval "$pages_array_name=()"

	if [[ -z $range ]]; then
		return 0
	fi

	# Split by commas and process each part
	IFS=',' read -ra parts <<<"$range"

	for part in "${parts[@]}"; do
		part=$(echo "$part" | tr -d ' ') # Remove spaces

		if [[ $part =~ ^[0-9]+$ ]]; then
			# Single page number
			eval "$pages_array_name+=(\"$part\")"
		elif [[ $part =~ ^[0-9]+-[0-9]+$ ]]; then
			# Range like "1-5"
			local start_page="${part%-*}"
			local end_page="${part#*-}"

			# Validate range
			if [[ $start_page -gt $end_page ]]; then
				log::error "Invalid page range: $part (start > end)"
				return 1
			fi

			# Add all pages in range
			for ((page = start_page; page <= end_page; page++)); do
				eval "$pages_array_name+=(\"$page\")"
			done
		elif [[ $part =~ ^[0-9]+-$ ]]; then
			# Open range like "5-" (from page 5 to end)
			local start_page="${part%-}"
			eval "$pages_array_name+=(\"${start_page}-\")"
		else
			log::error "Invalid page range part: $part"
			return 1
		fi
	done

	# Remove duplicates and sort using a temporary file approach
	local temp_file=$(mktemp)
	eval "printf '%s\n' \"\${${pages_array_name}[@]}\"" | sort -n >"$temp_file"

	# Read back the sorted unique values
	eval "$pages_array_name=()"
	while IFS= read -r line; do
		eval "$pages_array_name+=(\"$line\")"
	done <"$temp_file"

	rm -f "$temp_file"

	return 0
}

list_pdf_images() {
	local pdf_file="$1"
	local output_dir="$2"

	log::info "Listing images in PDF: $pdf_file"

	# Use pdfimages to list images
	if ! pdfimages -list "$pdf_file" >"$output_dir/pdf_images_list.txt" 2>/dev/null; then
		log::error "Failed to list images from PDF"
		return 1
	fi

	local image_count
	image_count=$(grep -c "^[[:space:]]*[0-9]" "$output_dir/pdf_images_list.txt" 2>/dev/null || echo "0")
	image_count=$(echo "$image_count" | tr -d '\n')

	if [[ $image_count -eq 0 ]]; then
		log::warn "No images found in PDF: $pdf_file"
		return 0
	fi

	log::info "Found $image_count images in PDF"

	if [[ $VERBOSE == true ]]; then
		log::info "Image details:"
		cat "$output_dir/pdf_images_list.txt"
	fi

	return 0
}

list_pdf_summary() {
	local pdf_file="$1"
	local output_dir="$2"

	log::info "Analyzing PDF: $pdf_file"

	local pages="unknown"
	if command -v pdfinfo >/dev/null 2>&1; then
		pages=$(pdfinfo "$pdf_file" 2>/dev/null | awk -F': *' '/^Pages/ {print $2; exit}')
		pages=${pages:-unknown}
	else
		log::warn "pdfinfo not available; cannot determine page count"
	fi

	local embedded_images="0"
	if command -v pdfimages >/dev/null 2>&1; then
		if pdfimages -list "$pdf_file" >"$output_dir/pdf_images_list.txt" 2>/dev/null; then
			embedded_images=$(grep -c "^[[:space:]]*[0-9]" "$output_dir/pdf_images_list.txt" 2>/dev/null || echo "0")
			embedded_images=$(echo "$embedded_images" | tr -d '\n')
		else
			log::warn "Failed to list embedded images via pdfimages"
		fi
	else
		log::warn "pdfimages not available; embedded image count unavailable"
	fi

	log::info "Pages: ${pages}"
	log::info "Embedded images: ${embedded_images}"

	if [[ $VERBOSE == true && -f "$output_dir/pdf_images_list.txt" ]]; then
		log::info "Embedded image details:"
		cat "$output_dir/pdf_images_list.txt"
	fi
}

extract_pdf_images() {
	local pdf_file="$1"
	local output_dir="$2"

	if [[ $QUIET != true ]]; then
		log::info "Extracting images from PDF: $pdf_file"
		log::info "Output directory: $output_dir"
	fi

	# Create temporary directory for extraction
	local temp_dir
	temp_dir=$(mktemp -d)

	# Extract images using pdfimages (embedded mode)
	local pdfimages_cmd="pdfimages"
	local pdfimages_args=()

	# Add format specification if not keeping original names
	if [[ $KEEP_ORIGINAL_NAMES == false ]]; then
		case "$FORMAT" in
		jpg | jpeg)
			pdfimages_args+=("-j")
			;;
		png)
			pdfimages_args+=("-png")
			;;
		tiff)
			pdfimages_args+=("-tiff")
			;;
		*)
			# For other formats, let pdfimages handle them
			;;
		esac
	fi

	# Add page range if specified
	if [[ -n $PAGE_RANGE ]]; then
		pdfimages_args+=("-f" "$(echo "$PAGE_RANGE" | cut -d'-' -f1)")
		pdfimages_args+=("-l" "$(echo "$PAGE_RANGE" | cut -d'-' -f2)")
	fi

	# Add output prefix
	pdfimages_args+=("$pdf_file" "$temp_dir/$PREFIX")

	if [[ $DRY_RUN == true ]]; then
		log::info "Would run: $pdfimages_cmd ${pdfimages_args[*]}"
		rm -rf "$temp_dir"
		return 0
	fi

	# Run pdfimages
	if ! $pdfimages_cmd "${pdfimages_args[@]}" 2>/dev/null; then
		log::error "Failed to extract images from PDF"
		rm -rf "$temp_dir"
		return 1
	fi

	# Count extracted images
	local extracted_count=0
	local processed_count=0

	for image_file in "$temp_dir"/*; do
		if [[ -f $image_file ]]; then
			((extracted_count++))

			local basename_file
			basename_file=$(basename "$image_file")
			local output_file="$output_dir/$basename_file"

			# Handle file naming
			if [[ $KEEP_ORIGINAL_NAMES == false ]]; then
				# Use template-based naming
				local page_num
				page_num=$(printf "%03d" "$extracted_count")
				output_file="$output_dir/${PREFIX}_${page_num}.$FORMAT"
			fi

			# Convert format if needed and apply quality settings
			if [[ $FORMAT != "png" && $FORMAT != "tiff" ]]; then
				if command -v convert >/dev/null 2>&1; then
					if ! convert "$image_file" -quality "$QUALITY" "$output_file" 2>/dev/null; then
						log::warn "Failed to convert $basename_file, copying original"
						cp "$image_file" "$output_file"
					fi
				else
					cp "$image_file" "$output_file"
				fi
			else
				cp "$image_file" "$output_file"
			fi

			((processed_count++))

			if [[ $VERBOSE == true ]]; then
				log::info "Extracted: $basename_file -> $(basename "$output_file")"
			fi
		fi
	done

	# Clean up temporary directory
	rm -rf "$temp_dir"

	if [[ $extracted_count -eq 0 ]]; then
		log::warn "No images were extracted from PDF"
		return 0
	fi

	log::success "Successfully extracted $processed_count images"

	# Extract metadata if requested
	if [[ $EXTRACT_METADATA == true ]]; then
		extract_pdf_metadata "$pdf_file" "$output_dir"
	fi

	return 0
}

extract_rasterized_pages() {
	local pdf_file="$1"
	local output_dir="$2"

	if [[ $QUIET != true ]]; then
		log::info "Rasterizing pages from PDF: $pdf_file"
		log::info "Output directory: $output_dir"
	fi

	local magick_cmd=""
	if command -v magick >/dev/null 2>&1; then
		magick_cmd="magick"
	elif command -v convert >/dev/null 2>&1; then
		magick_cmd="convert"
	else
		if [[ $DRY_RUN == true ]]; then
			# In dry-run mode, use a placeholder command for display purposes
			magick_cmd="magick"
		else
			log::error "ImageMagick not found (magick/convert)"
			return 1
		fi
	fi

	local density=300
	local processed_count=0
	local failed_count=0

	# Handle complex page ranges
	if [[ -n $PAGE_RANGE ]]; then
		# Parse complex page range
		if ! parse_complex_page_range "$PAGE_RANGE" pages_array; then
			return 1
		fi

		# Get the parsed pages array
		eval 'local pages_array=("${pages_array[@]}")'

		if [[ ${#pages_array[@]} -eq 0 ]]; then
			log::warn "No valid pages found in range: $PAGE_RANGE"
			return 0
		fi

		if [[ $VERBOSE == true ]]; then
			log::info "Processing pages: ${pages_array[*]}"
		fi

		# Process each page individually to maintain correct numbering
		local output_counter=1
		for page in "${pages_array[@]}"; do
			local output_file="$output_dir/${PREFIX}-$(printf "%02d" "$output_counter").$FORMAT"

			if [[ $page == *"-" ]]; then
				# Handle open range (e.g., "5-" means from page 5 to end)
				local start_page="${page%-}"
				local magick_start_page=$((start_page - 1))
				if [[ $DRY_RUN == true ]]; then
					log::info "Would run: $magick_cmd -density $density \"${pdf_file}[${magick_start_page}-]\" -quality $QUALITY \"$output_file\""
				else
					if $magick_cmd -density $density "${pdf_file}[${magick_start_page}-]" -quality "$QUALITY" "$output_file" 2>/dev/null; then
						((processed_count++))
					else
						((failed_count++))
						log::error "Failed to rasterize pages from $start_page to end"
					fi
				fi
				((output_counter++))
			else
				# Handle single page - convert 1-based page number to 0-based for ImageMagick
				local magick_page=$((page - 1))
				if [[ $DRY_RUN == true ]]; then
					log::info "Would run: $magick_cmd -density $density \"${pdf_file}[$magick_page]\" -quality $QUALITY \"$output_file\""
				else
					if $magick_cmd -density $density "${pdf_file}[$magick_page]" -quality "$QUALITY" "$output_file" 2>/dev/null; then
						((processed_count++))
					else
						((failed_count++))
						log::error "Failed to rasterize page $page"
					fi
				fi
				((output_counter++))
			fi
		done
	else
		# No page range specified - process all pages
		local output_pattern="$output_dir/${PREFIX}-%02d.$FORMAT"

		if [[ $DRY_RUN == true ]]; then
			log::info "Would run: $magick_cmd -density $density \"$pdf_file\" -quality $QUALITY \"$output_pattern\""
		else
			if $magick_cmd -density $density "$pdf_file" -quality "$QUALITY" "$output_pattern" 2>/dev/null; then
				# Count generated files
				shopt -s nullglob
				for f in "$output_dir"/"${PREFIX}-"*."$FORMAT"; do
					[[ -f $f ]] && ((processed_count++))
				done
				shopt -u nullglob
			else
				log::error "Failed to rasterize PDF pages"
				return 1
			fi
		fi
	fi

	if [[ $DRY_RUN == true ]]; then
		log::info "Dry run completed - no files were modified"
		return 0
	fi

	if [[ $processed_count -eq 0 ]]; then
		log::warn "No pages were rasterized from PDF"
		return 0
	fi

	if [[ $failed_count -gt 0 ]]; then
		log::warn "Successfully processed $processed_count pages, $failed_count failed"
	else
		echo ""
		log::success "Successfully rasterized $processed_count pages"
	fi

	if [[ $EXTRACT_METADATA == true ]]; then
		extract_pdf_metadata "$pdf_file" "$output_dir"
	fi

	return 0
}

extract_pdf_metadata() {
	local pdf_file="$1"
	local output_dir="$2"

	log::info "Extracting PDF metadata"

	# Create metadata file
	local metadata_file="$output_dir/pdf_metadata.txt"

	{
		echo "PDF File: $pdf_file"
		echo "Extraction Date: $(date)"
		echo "Extraction Tool: imgxsh-extract-pdf $(get_version)"
		echo ""
		echo "PDF Information:"
		pdfinfo "$pdf_file" 2>/dev/null || echo "pdfinfo not available"
	} >"$metadata_file"

	if [[ $VERBOSE == true ]]; then
		log::info "Metadata saved to: $metadata_file"
	fi
}

main() {
	# Parse command line arguments
	while [[ $# -gt 0 ]]; do
		case $1 in
		-h | --help)
			show_help
			exit 0
			;;
		-v | --version)
			echo "$(basename "$0") $(get_version)"
			exit 0
			;;
		-q | --quiet)
			QUIET=true
			shift
			;;
		--verbose)
			VERBOSE=true
			shift
			;;
		--dry-run)
			DRY_RUN=true
			shift
			;;
		--overwrite)
			OVERWRITE=true
			shift
			;;
		--backup)
			BACKUP=true
			shift
			;;
		-f | --format)
			FORMAT="$2"
			shift 2
			;;
		--quality)
			QUALITY="$2"
			shift 2
			;;
		-p | --prefix)
			PREFIX="$2"
			shift 2
			;;
		--page-range)
			PAGE_RANGE="$2"
			shift 2
			;;
		--list-only)
			LIST_ONLY=true
			shift
			;;
		--no-metadata)
			EXTRACT_METADATA=false
			shift
			;;
		--keep-names)
			KEEP_ORIGINAL_NAMES=true
			shift
			;;
		--embedded-images)
			EXTRACT_MODE="embedded"
			shift
			;;
		--check-deps)
			check_dependencies
			exit $?
			;;
		--update)
			# In test mode, avoid network calls and heavy operations
			if [[ ${TEST_MODE:-} == "true" ]]; then
				echo "update-imgxsh (test-mode)"
				exit 0
			fi
			if command -v update-imgxsh >/dev/null 2>&1; then
				update-imgxsh --check
			else
				log::error "update-imgxsh not available"
				exit 1
			fi
			;;
		--check-version)
			echo "imgxsh-extract-pdf $(get_version)"
			IMGXSH_REPO="jeromecoloma/imgxsh" "${SHELL_STARTER_ROOT}/scripts/check-version.sh" status || true
			exit 0
			;;
		-*)
			log::error "Unknown option: $1"
			show_help
			exit 1
			;;
		*)
			# Positional arguments
			if [[ -z $PDF_FILE ]]; then
				PDF_FILE="$1"
			elif [[ -z $OUTPUT_DIR ]]; then
				OUTPUT_DIR="$1"
			else
				log::error "Too many arguments"
				show_help
				exit 1
			fi
			shift
			;;
		esac
	done

	# Validate required arguments
	if [[ -z $PDF_FILE ]]; then
		log::error "PDF file is required"
		show_help
		exit 1
	fi

	if [[ -z $OUTPUT_DIR ]]; then
		log::error "Output directory is required"
		show_help
		exit 1
	fi

	# Validate inputs
	if ! validate_pdf_file "$PDF_FILE"; then
		exit 1
	fi

	if ! validate_output_dir "$OUTPUT_DIR"; then
		exit 1
	fi

	# Validate format
	if ! FORMAT=$(validate_format "$FORMAT"); then
		exit 1
	fi

	# Validate quality
	if ! validate_quality "$QUALITY"; then
		exit 1
	fi

	# Validate page range
	if ! parse_page_range "$PAGE_RANGE"; then
		exit 1
	fi

	# Check dependencies
	if ! check_dependencies; then
		exit 1
	fi

	# Set quiet mode
	if [[ $QUIET == true ]]; then
		VERBOSE=false
	fi

	# Main processing
	if [[ $QUIET != true ]]; then
		log::info "Starting PDF image extraction..."
		log::info "PDF: $PDF_FILE"
		log::info "Output: $OUTPUT_DIR"
		log::info "Format: $FORMAT"
		log::info "Quality: $QUALITY"
		if [[ -n $PAGE_RANGE ]]; then
			log::info "Page range: $PAGE_RANGE"
		fi
		if [[ $DRY_RUN == true ]]; then
			log::info "DRY RUN MODE - No files will be modified"
		fi
	fi

	# List only mode
	if [[ $LIST_ONLY == true ]]; then
		list_pdf_summary "$PDF_FILE" "$OUTPUT_DIR" || true
		exit 0
	fi

	# Extract
	if [[ $EXTRACT_MODE == "embedded" ]]; then
		if ! extract_pdf_images "$PDF_FILE" "$OUTPUT_DIR"; then
			exit 1
		fi
	else
		if ! extract_rasterized_pages "$PDF_FILE" "$OUTPUT_DIR"; then
			exit 1
		fi
	fi

	if [[ $QUIET != true ]]; then
		log::success "PDF image extraction completed successfully"
	fi
}

# Only run main if script is executed directly
if [[ ${BASH_SOURCE[0]} == "${0}" ]]; then
	main "$@"
fi
