#!/bin/bash

# imgxsh-extract-pdf - Extract images from PDF files using pdfimages/poppler-utils
# Extracts embedded images from PDF documents with metadata preservation and flexible naming

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SHELL_STARTER_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

source "${SHELL_STARTER_ROOT}/lib/main.sh"

# Default values
readonly DEFAULT_QUALITY=85
readonly DEFAULT_FORMAT="jpg"
readonly DEFAULT_PREFIX="page"

# Global variables
PDF_FILE=""
OUTPUT_DIR=""
QUALITY="${DEFAULT_QUALITY}"
FORMAT="${DEFAULT_FORMAT}"
PREFIX="${DEFAULT_PREFIX}"
PAGE_RANGE=""
VERBOSE=false
QUIET=false
DRY_RUN=false
OVERWRITE=false
BACKUP=false
LIST_ONLY=false
EXTRACT_METADATA=true
KEEP_ORIGINAL_NAMES=false

show_help() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS] PDF_FILE OUTPUT_DIR

Extract images from PDF files using pdfimages/poppler-utils.

ARGUMENTS:
    PDF_FILE              Path to the PDF file to extract images from
    OUTPUT_DIR            Directory to save extracted images

OPTIONS:
    -h, --help            Show this help message and exit
    -v, --version         Show version information and exit
    -q, --quiet           Suppress verbose output
    --verbose             Enable detailed logging
    --dry-run             Preview operations without execution
    --overwrite           Overwrite existing files without prompting
    --backup              Create backup of existing files before overwriting
    
    -f, --format FORMAT   Output format (jpg, png, tiff, bmp) [default: jpg]
    -q, --quality QUALITY Quality setting for lossy formats (1-100) [default: 85]
    -p, --prefix PREFIX   Prefix for extracted image names [default: page]
    --page-range RANGE    Extract specific pages (e.g., "1-5", "1,3,7", "2-")
    --list-only           List available images without extracting
    --no-metadata         Skip metadata extraction and preservation
    --keep-names          Keep original image names from PDF
    
    --check-deps          Check for required dependencies and exit
    --update              Check for imgxsh updates
    --check-version       Check current version information

EXAMPLES:
    # Extract all images to output directory
    $(basename "$0") document.pdf ./extracted/
    
    # Extract specific pages with custom naming
    $(basename "$0") --page-range "1-5" --prefix "chapter1" document.pdf ./images/
    
    # Extract as PNG with high quality
    $(basename "$0") --format png --quality 95 document.pdf ./high-res/
    
    # List available images without extracting
    $(basename "$0") --list-only document.pdf ./temp/
    
    # Dry run to preview operations
    $(basename "$0") --dry-run --verbose document.pdf ./output/

DEPENDENCIES:
    pdfimages (poppler-utils) - Required for PDF image extraction
    ImageMagick - Optional, for format conversion and quality control

FORMATS SUPPORTED:
    jpg, png, tiff, bmp - Output formats supported by ImageMagick
    Original format detection from PDF embedded images

For more information, visit: https://github.com/jeromecoloma/imgxsh
EOF
}

check_dependencies() {
    local missing_deps=()
    local optional_deps=()
    
    # Check for pdfimages (required)
    if ! command -v pdfimages >/dev/null 2>&1; then
        missing_deps+=("pdfimages")
    fi
    
    # Check for ImageMagick (optional for format conversion)
    if ! command -v convert >/dev/null 2>&1 && ! command -v magick >/dev/null 2>&1; then
        optional_deps+=("ImageMagick")
    fi
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        log::error "Required dependencies missing: ${missing_deps[*]}"
        log::info "Install pdfimages:"
        log::info "  macOS: brew install poppler"
        log::info "  Ubuntu/Debian: sudo apt-get install poppler-utils"
        log::info "  CentOS/RHEL: sudo yum install poppler-utils"
        log::info "  Arch Linux: sudo pacman -S poppler"
        return 1
    fi
    
    if [[ ${#optional_deps[@]} -gt 0 ]]; then
        log::warn "Optional dependencies missing: ${optional_deps[*]}"
        log::info "ImageMagick is recommended for format conversion and quality control"
        log::info "Install ImageMagick:"
        log::info "  macOS: brew install imagemagick"
        log::info "  Ubuntu/Debian: sudo apt-get install imagemagick"
        log::info "  CentOS/RHEL: sudo yum install ImageMagick"
        log::info "  Arch Linux: sudo pacman -S imagemagick"
    fi
    
    return 0
}

validate_pdf_file() {
    local pdf_file="$1"
    
    if [[ ! -f "$pdf_file" ]]; then
        log::error "PDF file does not exist: $pdf_file"
        return 1
    fi
    
    if [[ ! -r "$pdf_file" ]]; then
        log::error "Cannot read PDF file: $pdf_file"
        return 1
    fi
    
    # Check if file is actually a PDF
    if ! file "$pdf_file" | grep -qi "pdf document"; then
        log::error "File does not appear to be a PDF: $pdf_file"
        return 1
    fi
    
    return 0
}

validate_output_dir() {
    local output_dir="$1"
    
    if [[ -f "$output_dir" ]]; then
        log::error "Output path is a file, not a directory: $output_dir"
        return 1
    fi
    
    if [[ ! -d "$output_dir" ]]; then
        if [[ "$DRY_RUN" == true ]]; then
            log::info "Would create output directory: $output_dir"
        else
            log::info "Creating output directory: $output_dir"
            if ! mkdir -p "$output_dir"; then
                log::error "Failed to create output directory: $output_dir"
                return 1
            fi
        fi
    fi
    
    if [[ ! -w "$output_dir" ]] && [[ "$DRY_RUN" != true ]]; then
        log::error "Cannot write to output directory: $output_dir"
        return 1
    fi
    
    return 0
}

validate_format() {
    local format="$1"
    local valid_formats=("jpg" "jpeg" "png" "tiff" "bmp")
    
    # Convert to lowercase for comparison
    format=$(echo "$format" | tr '[:upper:]' '[:lower:]')
    
    for valid_format in "${valid_formats[@]}"; do
        if [[ "$format" == "$valid_format" ]]; then
            echo "$format"
            return 0
        fi
    done
    
    log::error "Invalid format: $format"
    log::info "Supported formats: ${valid_formats[*]}"
    return 1
}

validate_quality() {
    local quality="$1"
    
    if ! [[ "$quality" =~ ^[0-9]+$ ]]; then
        log::error "Quality must be a number: $quality"
        return 1
    fi
    
    if [[ "$quality" -lt 1 || "$quality" -gt 100 ]]; then
        log::error "Quality must be between 1 and 100: $quality"
        return 1
    fi
    
    return 0
}

parse_page_range() {
    local range="$1"
    
    if [[ -z "$range" ]]; then
        return 0
    fi
    
    # Validate page range format
    if [[ ! "$range" =~ ^[0-9,-]+$ ]]; then
        log::error "Invalid page range format: $range"
        log::info "Valid formats: '1-5', '1,3,7', '2-', '1-3,5,7-10'"
        return 1
    fi
    
    return 0
}

list_pdf_images() {
    local pdf_file="$1"
    local output_dir="$2"
    
    log::info "Listing images in PDF: $pdf_file"
    
    # Use pdfimages to list images
    if ! pdfimages -list "$pdf_file" > "$output_dir/pdf_images_list.txt" 2>/dev/null; then
        log::error "Failed to list images from PDF"
        return 1
    fi
    
    local image_count
    image_count=$(grep -c "^[[:space:]]*[0-9]" "$output_dir/pdf_images_list.txt" 2>/dev/null || echo "0")
    image_count=$(echo "$image_count" | tr -d '\n')
    
    if [[ "$image_count" -eq 0 ]]; then
        log::warn "No images found in PDF: $pdf_file"
        return 0
    fi
    
    log::info "Found $image_count images in PDF"
    
    if [[ "$VERBOSE" == true ]]; then
        log::info "Image details:"
        cat "$output_dir/pdf_images_list.txt"
    fi
    
    return 0
}

extract_pdf_images() {
    local pdf_file="$1"
    local output_dir="$2"
    
    if [[ "$QUIET" != true ]]; then
        log::info "Extracting images from PDF: $pdf_file"
        log::info "Output directory: $output_dir"
    fi
    
    # Create temporary directory for extraction
    local temp_dir
    temp_dir=$(mktemp -d)
    
    # Extract images using pdfimages
    local pdfimages_cmd="pdfimages"
    local pdfimages_args=()
    
    # Add format specification if not keeping original names
    if [[ "$KEEP_ORIGINAL_NAMES" == false ]]; then
        case "$FORMAT" in
            jpg|jpeg)
                pdfimages_args+=("-j")
                ;;
            png)
                pdfimages_args+=("-png")
                ;;
            tiff)
                pdfimages_args+=("-tiff")
                ;;
            *)
                # For other formats, let pdfimages handle them
                ;;
        esac
    fi
    
    # Add page range if specified
    if [[ -n "$PAGE_RANGE" ]]; then
        pdfimages_args+=("-f" "$(echo "$PAGE_RANGE" | cut -d'-' -f1)")
        pdfimages_args+=("-l" "$(echo "$PAGE_RANGE" | cut -d'-' -f2)")
    fi
    
    # Add output prefix
    pdfimages_args+=("$pdf_file" "$temp_dir/$PREFIX")
    
    if [[ "$DRY_RUN" == true ]]; then
        log::info "Would run: $pdfimages_cmd ${pdfimages_args[*]}"
        rm -rf "$temp_dir"
        return 0
    fi
    
    # Run pdfimages
    if ! $pdfimages_cmd "${pdfimages_args[@]}" 2>/dev/null; then
        log::error "Failed to extract images from PDF"
        rm -rf "$temp_dir"
        return 1
    fi
    
    # Count extracted images
    local extracted_count=0
    local processed_count=0
    
    for image_file in "$temp_dir"/*; do
        if [[ -f "$image_file" ]]; then
            ((extracted_count++))
            
            local basename_file
            basename_file=$(basename "$image_file")
            local output_file="$output_dir/$basename_file"
            
            # Handle file naming
            if [[ "$KEEP_ORIGINAL_NAMES" == false ]]; then
                # Use template-based naming
                local page_num
                page_num=$(printf "%03d" "$extracted_count")
                output_file="$output_dir/${PREFIX}_${page_num}.$FORMAT"
            fi
            
            # Convert format if needed and apply quality settings
            if [[ "$FORMAT" != "png" && "$FORMAT" != "tiff" ]]; then
                if command -v convert >/dev/null 2>&1; then
                    if ! convert "$image_file" -quality "$QUALITY" "$output_file" 2>/dev/null; then
                        log::warn "Failed to convert $basename_file, copying original"
                        cp "$image_file" "$output_file"
                    fi
                else
                    cp "$image_file" "$output_file"
                fi
            else
                cp "$image_file" "$output_file"
            fi
            
            ((processed_count++))
            
            if [[ "$VERBOSE" == true ]]; then
                log::info "Extracted: $basename_file -> $(basename "$output_file")"
            fi
        fi
    done
    
    # Clean up temporary directory
    rm -rf "$temp_dir"
    
    if [[ "$extracted_count" -eq 0 ]]; then
        log::warn "No images were extracted from PDF"
        return 0
    fi
    
    log::success "Successfully extracted $processed_count images"
    
    # Extract metadata if requested
    if [[ "$EXTRACT_METADATA" == true ]]; then
        extract_pdf_metadata "$pdf_file" "$output_dir"
    fi
    
    return 0
}

extract_pdf_metadata() {
    local pdf_file="$1"
    local output_dir="$2"
    
    log::info "Extracting PDF metadata"
    
    # Create metadata file
    local metadata_file="$output_dir/pdf_metadata.txt"
    
    {
        echo "PDF File: $pdf_file"
        echo "Extraction Date: $(date)"
        echo "Extraction Tool: imgxsh-extract-pdf $(get_version)"
        echo ""
        echo "PDF Information:"
        pdfinfo "$pdf_file" 2>/dev/null || echo "pdfinfo not available"
    } > "$metadata_file"
    
    if [[ "$VERBOSE" == true ]]; then
        log::info "Metadata saved to: $metadata_file"
    fi
}

main() {
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--version)
                echo "$(basename "$0") $(get_version)"
                exit 0
                ;;
            -q|--quiet)
                QUIET=true
                shift
                ;;
            --verbose)
                VERBOSE=true
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --overwrite)
                OVERWRITE=true
                shift
                ;;
            --backup)
                BACKUP=true
                shift
                ;;
            -f|--format)
                FORMAT="$2"
                shift 2
                ;;
            --quality)
                QUALITY="$2"
                shift 2
                ;;
            -p|--prefix)
                PREFIX="$2"
                shift 2
                ;;
            --page-range)
                PAGE_RANGE="$2"
                shift 2
                ;;
            --list-only)
                LIST_ONLY=true
                shift
                ;;
            --no-metadata)
                EXTRACT_METADATA=false
                shift
                ;;
            --keep-names)
                KEEP_ORIGINAL_NAMES=true
                shift
                ;;
            --check-deps)
                check_dependencies
                exit $?
                ;;
            --update)
                if command -v update-shell-starter >/dev/null 2>&1; then
                    update-shell-starter
                else
                    log::error "update-shell-starter not available"
                    exit 1
                fi
                ;;
            --check-version)
                echo "imgxsh-extract-pdf $(get_version)"
                if command -v update-shell-starter >/dev/null 2>&1; then
                    update-shell-starter --check
                fi
                exit 0
                ;;
            -*)
                log::error "Unknown option: $1"
                show_help
                exit 1
                ;;
            *)
                # Positional arguments
                if [[ -z "$PDF_FILE" ]]; then
                    PDF_FILE="$1"
                elif [[ -z "$OUTPUT_DIR" ]]; then
                    OUTPUT_DIR="$1"
                else
                    log::error "Too many arguments"
                    show_help
                    exit 1
                fi
                shift
                ;;
        esac
    done
    
    # Validate required arguments
    if [[ -z "$PDF_FILE" ]]; then
        log::error "PDF file is required"
        show_help
        exit 1
    fi
    
    if [[ -z "$OUTPUT_DIR" ]]; then
        log::error "Output directory is required"
        show_help
        exit 1
    fi
    
    # Validate inputs
    if ! validate_pdf_file "$PDF_FILE"; then
        exit 1
    fi
    
    if ! validate_output_dir "$OUTPUT_DIR"; then
        exit 1
    fi
    
    # Validate format
    if ! FORMAT=$(validate_format "$FORMAT"); then
        exit 1
    fi
    
    # Validate quality
    if ! validate_quality "$QUALITY"; then
        exit 1
    fi
    
    # Validate page range
    if ! parse_page_range "$PAGE_RANGE"; then
        exit 1
    fi
    
    # Check dependencies
    if ! check_dependencies; then
        exit 1
    fi
    
    # Set quiet mode
    if [[ "$QUIET" == true ]]; then
        VERBOSE=false
    fi
    
    # Main processing
    if [[ "$QUIET" != true ]]; then
        log::info "Starting PDF image extraction..."
        log::info "PDF: $PDF_FILE"
        log::info "Output: $OUTPUT_DIR"
        log::info "Format: $FORMAT"
        log::info "Quality: $QUALITY"
        if [[ -n "$PAGE_RANGE" ]]; then
            log::info "Page range: $PAGE_RANGE"
        fi
        if [[ "$DRY_RUN" == true ]]; then
            log::info "DRY RUN MODE - No files will be modified"
        fi
    fi
    
    # List only mode
    if [[ "$LIST_ONLY" == true ]]; then
        if ! list_pdf_images "$PDF_FILE" "$OUTPUT_DIR"; then
            exit 1
        fi
        exit 0
    fi
    
    # Extract images
    if ! extract_pdf_images "$PDF_FILE" "$OUTPUT_DIR"; then
        exit 1
    fi
    
    if [[ "$QUIET" != true ]]; then
        log::success "PDF image extraction completed successfully"
    fi
}

# Only run main if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
