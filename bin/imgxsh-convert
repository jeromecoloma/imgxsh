#!/bin/bash

# imgxsh-convert - Convert images between formats with quality control
# Supports PNG, JPG, WebP, TIFF, BMP formats with ImageMagick integration

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SHELL_STARTER_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

source "${SHELL_STARTER_ROOT}/lib/main.sh"

show_help() {
	cat <<EOF
Usage: $(basename "$0") [OPTIONS] INPUT OUTPUT

Convert images between different formats with quality control.

ARGUMENTS:
    INPUT             Input image file or directory (supports batch processing)
    OUTPUT            Output image file or directory

OPTIONS:
    -h, --help        Show this help message and exit
    -v, --version     Show version information and exit
    -q, --quality N   Set quality (1-100, default varies by format)
    -f, --format FMT  Output format (png, jpg, webp, tiff, bmp)
    --backup          Create backup of original file before conversion
    --overwrite       Overwrite output file if it exists
    --verbose         Enable verbose output
    --quiet           Suppress non-essential output
    --dry-run         Show what would be done without executing

SUPPORTED FORMATS:
    PNG               Lossless format, good for images with transparency
    JPG/JPEG          Lossy format, good for photographs (default quality: 85)
    WebP              Modern format with excellent compression (default quality: 90)
    TIFF              High-quality format for professional use
    BMP               Uncompressed bitmap format

QUALITY SETTINGS:
    PNG, TIFF, BMP    Quality setting ignored (lossless formats)
    JPG               1-100 (default: 85, recommended: 75-95)
    WebP              1-100 (default: 90, recommended: 80-95)

EXAMPLES:
    # Single file conversion
    $(basename "$0") photo.png photo.jpg
    $(basename "$0") --quality 95 image.jpg image.webp
    $(basename "$0") --format png --backup document.pdf document.png
    $(basename "$0") --dry-run --verbose input.tiff output.jpg
    
    # Batch directory conversion
    $(basename "$0") --format webp --quality 90 ./photos/ ./converted/
    $(basename "$0") --format jpg --quality 85 --overwrite ./images/ ./web_images/
    $(basename "$0") --dry-run --verbose --format png ./input/ ./output/

DEPENDENCIES:
    ImageMagick       Required for all format conversions
    
BATCH PROCESSING:
    - Supports directory input for recursive batch processing
    - Preserves directory structure in output
    - Shows progress with file counts: [X/Y] Processing: filename
    - Continues processing even if individual files fail
    - All conversion options work in batch mode

NOTES:
    - Output format is determined by file extension unless --format is specified
    - Use --dry-run to preview operations before execution
    - Quality settings only apply to lossy formats (JPG, WebP)
    - Original files are preserved unless --overwrite is used with same input/output
EOF
}

validate_dependencies() {
	local missing_deps=()

	# Check for ImageMagick (either magick or convert command)
	if ! command -v magick >/dev/null 2>&1 && ! command -v convert >/dev/null 2>&1; then
		missing_deps+=("ImageMagick (magick command)")
	fi

	if ! command -v identify >/dev/null 2>&1; then
		missing_deps+=("ImageMagick (identify command)")
	fi

	if [[ ${#missing_deps[@]} -gt 0 ]]; then
		log::error "Missing required dependencies: ${missing_deps[*]}"
		log::info "Install ImageMagick:"
		log::info "  macOS:    brew install imagemagick"
		log::info "  Ubuntu:   sudo apt-get install imagemagick"
		log::info "  CentOS:   sudo yum install ImageMagick"
		return 1
	fi

	return 0
}

validate_format() {
	local format="$1"
	local supported_formats=("png" "jpg" "jpeg" "webp" "tiff" "bmp")

	# Convert to lowercase for comparison
	format=$(echo "$format" | tr '[:upper:]' '[:lower:]')

	for supported in "${supported_formats[@]}"; do
		if [[ $format == "$supported" ]]; then
			return 0
		fi
	done

	log::error "Unsupported format: $format"
	log::info "Supported formats: ${supported_formats[*]}"
	return 1
}

get_default_quality() {
	local format="$1"

	case "$format" in
	jpg | jpeg)
		echo "85"
		;;
	webp)
		echo "90"
		;;
	*)
		echo "100" # For lossless formats, quality doesn't apply but we return 100
		;;
	esac
}

extract_format_from_filename() {
	local filename="$1"
	local extension

	extension="${filename##*.}"
	extension=$(echo "$extension" | tr '[:upper:]' '[:lower:]')

	# Handle common variations
	case "$extension" in
	jpeg)
		echo "jpg"
		;;
	tif)
		echo "tiff"
		;;
	*)
		echo "$extension"
		;;
	esac
}

validate_quality() {
	local quality="$1"

	if ! [[ $quality =~ ^[0-9]+$ ]] || [[ $quality -lt 1 ]] || [[ $quality -gt 100 ]]; then
		log::error "Quality must be a number between 1 and 100"
		return 1
	fi

	return 0
}

get_image_info() {
	local file="$1"
	local info

	if ! info=$(identify "$file" 2>/dev/null); then
		log::error "Cannot read image information from: $file"
		return 1
	fi

	echo "$info"
}

create_backup() {
	local file="$1"
	local backup_file="${file}.backup.$(date +%Y%m%d_%H%M%S)"

	if cp "$file" "$backup_file"; then
		log::info "Created backup: $backup_file"
		return 0
	else
		log::error "Failed to create backup of: $file"
		return 1
	fi
}

convert_image() {
	local input="$1"
	local output="$2"
	local format="$3"
	local quality="$4"
	local verbose="$5"
	local dry_run="$6"

	# Use the appropriate ImageMagick command (magick or convert)
	local imagemagick_cmd="magick"
	if ! command -v magick >/dev/null 2>&1 && command -v convert >/dev/null 2>&1; then
		imagemagick_cmd="convert"
	fi

	local convert_cmd=("$imagemagick_cmd" "$input")
	local format_args=()

	# Add format-specific arguments
	case "$format" in
	jpg | jpeg)
		format_args+=("-quality" "$quality")
		;;
	webp)
		format_args+=("-quality" "$quality")
		;;
	png)
		# PNG doesn't need quality setting
		;;
	tiff)
		# TIFF doesn't need quality setting
		;;
	bmp)
		# BMP doesn't need quality setting
		;;
	esac

	# For format override, we need to specify the format properly
	# ImageMagick uses the format: prefix syntax for explicit format specification
	local output_with_format="$output"
	if [[ -n $format ]]; then
		# Convert format to ImageMagick format specification
		case "$format" in
		jpg | jpeg) output_with_format="JPEG:$output" ;;
		webp) output_with_format="WEBP:$output" ;;
		png) output_with_format="PNG:$output" ;;
		tiff) output_with_format="TIFF:$output" ;;
		bmp) output_with_format="BMP:$output" ;;
		esac
	fi

	# Add format arguments and output file
	if [[ ${#format_args[@]} -gt 0 ]]; then
		convert_cmd+=("${format_args[@]}")
	fi
	convert_cmd+=("$output_with_format")

	if [[ $dry_run == true ]]; then
		log::info "Would execute: ${convert_cmd[*]}"
		return 0
	fi

	if [[ $verbose == true ]]; then
		log::info "Executing: ${convert_cmd[*]}"
	fi

	if "${convert_cmd[@]}"; then
		return 0
	else
		log::error "Image conversion failed"
		return 1
	fi
}

# Validate output path for batch processing
validate_output_path() {
	local output="$1"
	local input_is_dir="$2"

	if [[ $input_is_dir == "true" ]]; then
		# For directory input, output should be a directory
		if [[ -f $output ]]; then
			log::error "Output must be a directory when input is a directory: $output"
			return 1
		fi

		# Create output directory if it doesn't exist
		if [[ ! -d $output ]]; then
			if [[ ${DRY_RUN:-false} != "true" ]]; then
				mkdir -p "$output" || {
					log::error "Cannot create output directory: $output"
					return 1
				}
				log::info "Created output directory: $output"
			else
				log::info "Would create output directory: $output"
			fi
		fi
	else
		# For file input, ensure output directory exists
		local output_dir
		output_dir="$(dirname "$output")"

		if [[ ! -d $output_dir ]]; then
			if [[ ${DRY_RUN:-false} != "true" ]]; then
				mkdir -p "$output_dir" || {
					log::error "Cannot create output directory: $output_dir"
					return 1
				}
				log::info "Created output directory: $output_dir"
			else
				log::info "Would create output directory: $output_dir"
			fi
		fi
	fi

	return 0
}

# Process directory for batch conversion
process_directory() {
	local input_dir="$1"
	local output_dir="$2"
	local format="$3"
	local quality="$4"
	local backup="$5"
	local overwrite="$6"
	local verbose="$7"
	local dry_run="$8"

	local processed=0
	local failed=0

	# Find image files
	local image_files=()
	while IFS= read -r -d '' file; do
		image_files+=("$file")
	done < <(find "$input_dir" -type f \( -iname "*.png" -o -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.webp" -o -iname "*.tiff" -o -iname "*.tif" -o -iname "*.bmp" -o -iname "*.gif" \) -print0)

	if [[ ${#image_files[@]} -eq 0 ]]; then
		log::warn "No image files found in directory: $input_dir"
		return 0
	fi

	log::info "Found ${#image_files[@]} image files to process"

	for input_file in "${image_files[@]}"; do
		# Determine output file path
		local relative_path
		relative_path="${input_file#"$input_dir"}"
		relative_path="${relative_path#/}" # Remove leading slash

		local output_file="$output_dir/$relative_path"

		# Change extension if format is specified
		if [[ $format != "auto" ]]; then
			local base_name
			base_name="${output_file%.*}"
			output_file="${base_name}.${format}"
		fi

		# Ensure parent directory exists for nested outputs
		local parent_dir
		parent_dir="$(dirname "$output_file")"
		if [[ ! -d $parent_dir ]]; then
			if [[ ${DRY_RUN:-false} == "true" ]]; then
				log::info "Would create output subdirectory: $parent_dir"
			else
				mkdir -p "$parent_dir" || {
					log::error "Cannot create output subdirectory: $parent_dir"
					((failed++))
					continue
				}
			fi
		fi

		# Check if output file exists
		if [[ -f $output_file && $overwrite != "true" ]]; then
			log::warn "Output file exists, skipping: $output_file"
			continue
		fi

		# Create backup if requested
		if [[ $backup == "true" ]] && [[ ${DRY_RUN:-false} != "true" ]]; then
			if [[ -f $input_file ]] && [[ $input_file != "$output_file" ]]; then
				local backup_file="${input_file}.backup.$(date +%Y%m%d_%H%M%S)"
				if cp "$input_file" "$backup_file"; then
					if [[ $verbose == "true" ]]; then
						log::info "Created backup: $backup_file"
					fi
				else
					log::error "Failed to create backup of: $input_file"
					((failed++))
					continue
				fi
			fi
		fi

		# Process the file
		# Progress indicator
		if [[ ${QUIET:-false} != "true" ]]; then
			local idx_msg
			idx_msg="[$((processed + failed + 1))/${#image_files[@]}] Processing: $relative_path"
			log::info "$idx_msg"
		fi
		local spinner_active=false
		if [[ ${DRY_RUN:-false} != "true" && ${QUIET:-false} != "true" ]]; then
			spinner::start "Converting $relative_path"
			spinner_active=true
		fi
		if convert_image "$input_file" "$output_file" "$format" "$quality" "$verbose" "$dry_run"; then
			((processed++))
		else
			((failed++))
		fi
		if [[ $spinner_active == true ]]; then
			spinner::stop || true
		fi
	done

	log::info "Processed: $processed files, Failed: $failed files"

	if [[ $failed -gt 0 ]]; then
		return 1
	fi

	return 0
}

main() {
	# Default values
	local quality=""
	local format=""
	local backup=false
	local overwrite=false
	local verbose=false
	local quiet=false
	local dry_run=false
	local input=""
	local output=""

	# Parse command line arguments
	while [[ $# -gt 0 ]]; do
		case $1 in
		-h | --help)
			show_help
			exit 0
			;;
		-v | --version)
			echo "$(basename "$0") $(get_version)"
			exit 0
			;;
		-q | --quality)
			quality="$2"
			shift 2
			;;
		-f | --format)
			format="$2"
			shift 2
			;;
		--backup)
			backup=true
			shift
			;;
		--overwrite)
			overwrite=true
			shift
			;;
		--verbose)
			verbose=true
			shift
			;;
		--quiet)
			quiet=true
			shift
			;;
		--dry-run)
			dry_run=true
			shift
			;;
		--update)
			if [[ ${TEST_MODE:-} == "true" ]]; then
				echo "update-imgxsh (test-mode)"
				exit 0
			fi
			if command -v update-imgxsh >/dev/null 2>&1; then
				update-imgxsh --check
			else
				log::error "update-imgxsh not available"
				exit 1
			fi
			;;
		--check-version)
			echo "imgxsh-convert $(get_version)"
			IMGXSH_REPO="jeromecoloma/imgxsh" "${SHELL_STARTER_ROOT}/scripts/check-version.sh" status || true
			exit 0
			;;
		-*)
			log::error "Unknown option: $1"
			show_help
			exit 1
			;;
		*)
			# Positional arguments
			if [[ -z $input ]]; then
				input="$1"
			elif [[ -z $output ]]; then
				output="$1"
			else
				log::error "Too many arguments"
				show_help
				exit 1
			fi
			shift
			;;
		esac
	done

	# Validate required arguments
	if [[ -z $input ]]; then
		log::error "Input file or directory is required"
		show_help
		exit 1
	fi

	if [[ -z $output ]]; then
		log::error "Output file or directory is required"
		show_help
		exit 1
	fi

	# Validate dependencies
	if ! validate_dependencies; then
		exit 1
	fi

	# Determine if input is directory
	local input_is_dir=false
	if [[ -d $input ]]; then
		input_is_dir=true
	elif [[ -f $input ]]; then
		input_is_dir=false
	else
		log::error "Input path does not exist: $input"
		exit 1
	fi

	# Validate input file/directory
	if [[ $input_is_dir == "false" ]] && [[ ! -r $input ]]; then
		log::error "Cannot read input file: $input"
		exit 1
	fi

	# Determine output format
	if [[ -z $format ]]; then
		format=$(extract_format_from_filename "$output")
		if [[ $verbose == true ]]; then
			log::info "Detected output format from filename: $format"
		fi
	fi

	# Validate format
	if ! validate_format "$format"; then
		exit 1
	fi

	# Set default quality if not specified
	if [[ -z $quality ]]; then
		quality=$(get_default_quality "$format")
		if [[ $verbose == true ]]; then
			log::info "Using default quality for $format: $quality"
		fi
	fi

	# Validate quality
	if ! validate_quality "$quality"; then
		exit 1
	fi

	# Validate output path
	if ! validate_output_path "$output" "$input_is_dir"; then
		exit 1
	fi

	# Check if output file exists
	if [[ -f $output ]] && [[ $overwrite != true ]] && [[ $dry_run != true ]]; then
		log::error "Output file exists: $output"
		log::info "Use --overwrite to replace existing file"
		exit 1
	fi

	# Get input image information
	if [[ $verbose == true ]] || [[ $dry_run == true ]]; then
		local input_info
		if input_info=$(get_image_info "$input"); then
			log::info "Input image: $input_info"
		fi
	fi

	# Create backup if requested
	if [[ $backup == true ]] && [[ $dry_run != true ]]; then
		if [[ -f $input ]] && [[ $input != "$output" ]]; then
			if ! create_backup "$input"; then
				exit 1
			fi
		fi
	fi

	# Show operation summary
	if [[ $verbose == true ]] || [[ $dry_run == true ]]; then
		log::info "Conversion summary:"
		log::info "  Input:    $input"
		log::info "  Output:   $output"
		log::info "  Format:   $format"
		log::info "  Quality:  $quality"
		log::info "  Backup:   $backup"
		log::info "  Dry-run:  $dry_run"
	fi

	# Set global variables for use in functions
	export DRY_RUN="$dry_run"
	export VERBOSE="$verbose"
	export QUIET="$quiet"

	# Show operation summary
	if [[ $verbose == true ]] || [[ $dry_run == true ]]; then
		log::info "Starting image conversion operation..."
		if [[ $input_is_dir == "true" ]]; then
			log::info "Input directory: $input"
			log::info "Output directory: $output"
		else
			log::info "Input file: $input"
			log::info "Output file: $output"
		fi
		log::info "Format: $format"
		log::info "Quality: $quality"
		if [[ $backup == "true" ]]; then
			log::info "Backup: enabled"
		fi
		if [[ $dry_run == "true" ]]; then
			log::info "Mode: dry-run (preview only)"
		fi
	fi

	# Process files
	if [[ $input_is_dir == "true" ]]; then
		if ! process_directory "$input" "$output" "$format" "$quality" "$backup" "$overwrite" "$verbose" "$dry_run"; then
			exit 1
		fi
	else
		# Single file processing
		if [[ $verbose == true ]] && [[ $dry_run != true ]]; then
			spinner::start "Converting $input to $format format"
		fi

		if convert_image "$input" "$output" "$format" "$quality" "$verbose" "$dry_run"; then
			if [[ $verbose == true ]] && [[ $dry_run != true ]]; then
				spinner::stop
			fi

			if [[ $dry_run == true ]]; then
				log::success "Dry-run completed - no files were modified"
			else
				log::success "Successfully converted $input to $output"

				# Show output file information
				if [[ $verbose == true ]]; then
					local output_info
					if output_info=$(get_image_info "$output"); then
						log::info "Output image: $output_info"
					fi
				fi
			fi
		else
			if [[ $verbose == true ]] && [[ $dry_run != true ]]; then
				spinner::stop
			fi
			log::error "Conversion failed"
			exit 1
		fi
	fi

	if [[ $verbose != "true" ]] && [[ $dry_run != "true" ]]; then
		log::success "Conversion operation completed successfully"
	fi
}

# Only run main if script is executed directly
if [[ ${BASH_SOURCE[0]} == "${0}" ]]; then
	main "$@"
fi
